import {$, rndInt, areaIsClear, updateNeighbours} from './helpers';

export default class Dungeon {
    constructor(side) {
        this.side = side;
        this.cells = 0;
        this.player = {};
        this.exit = {};
        this.rooms = [];
    }

    initialize() {
        const holder = $(".holder");
        for (let i = 0; i < this.side * this.side; i++) {
            const e = document.createElement('div');
            e.className = "cell";
            e.id = `c${Math.floor(i % this.side)}-${Math.floor(i / this.side)}`;
            holder.appendChild(e);
        }
    };

    buildNewRoom(cells) {

        /* 'cells' is the number of "free cells" we want to have in the the room
        * Free cells are generated by 'chunks' and then connected by tunnels / passages */

        while (document.querySelectorAll(".free").length <= cells) this.generateChunks();

        start:
            for (let x = 0; x < 20; x++) {
                for (let y = 0; y < 20; y++) {
                    if ([...$(`#c${x}-${y}`).classList].indexOf('free') >= 0) {
                        $(`#c${x}-${y}`).className = ("cell player");
                        this.player.x = x;
                        this.player.y = y;
                        break start;
                    }
                }
            }

        finish:
            for (let x = 19; x >= 0; x--) {
                for (let y = 19; y >= 0; y--) {
                    if ([...$(`#c${x}-${y}`).classList].indexOf('free') >= 0) {
                        $(`#c${x}-${y}`).classList.add("finish");
                        this.exit.x = x;
                        this.exit.y = y;
                        break finish;
                    }
                }
            }
        for (let r = 0; r < this.rooms.length - 1; r++) {
            this.buildHorizontalTunnel(this.rooms[r].cx, this.rooms[r + 1].cx, this.rooms[r].cy);
            this.buildVerticalTunnel(this.rooms[r].cy, this.rooms[r + 1].cy, this.rooms[r + 1].cx);
        }

        this.cells = cells;
        this.movePlayerTo(this.player.x, this.player.y);
    };

    generateChunks() {
        let w = Math.floor(Math.random() * 4) + 3;
        let h = Math.floor(Math.random() * 4) + 3;

        if (!(w % 2)) w += 1;
        if (!(h % 2)) h += 1;
        /*'chunks of cells must have odd width and height to get the proper center */

        let x = Math.floor(Math.random() * (19 - w)) + 1;
        let y = Math.floor(Math.random() * (19 - h)) + 1;

        for (let i = y; i < y + h; i++) {
            for (let j = x; j < x + w; j++) {
                $(`#c${j}-${i}`).classList.add("free");
            }
        }

        this.rooms.push({
            cx: x + Math.floor(w / 2),
            cy: y + Math.floor(h / 2)
        });
    };

    buildHorizontalTunnel(x1, x2, y) {
        let newx1 = Math.min(x1, x2);
        let newx2 = Math.max(x1, x2);
        for (let x = newx1; x <= newx2; x++) {
            $(`#c${x}-${y}`).classList.add("free")
        }
    };

    buildVerticalTunnel(y1, y2, x) {
        let newy1 = Math.min(y1, y2);
        let newy2 = Math.max(y1, y2);
        for (let y = newy1; y <= newy2; y++) {
            $(`#c${x}-${y}`).classList.add("free")
        }
    };

    // populateRoom() {
    //     let itemNumber = Math.floor(this.cells / 20);
    //     while (itemNumber) {
    //         const row = rndInt(2, this.side - 2);
    //         const column = rndInt(2, this.side - 2);
    //         if (areaIsClear(x, y)) {
    //             const cell = $(`#c${x}-${y}`);
    //             cell.classList.add("item");
    //             cell.classList.remove("free");
    //             itemNumber--;
    //         }
    //     }
    // }

    movePlayerTo(x, y) {
        const newPosition = $(`#c${x}-${y}`);
        const oldPosition = $(`#c${this.player.x}-${this.player.y}`);

        if ([...newPosition.classList].indexOf("free") >= 0) {
            oldPosition.classList.remove("player", "fade");
            oldPosition.classList.add("free");
            newPosition.classList.remove("free", "fade");
            newPosition.classList.add("player");
            updateNeighbours(x, y);
            this.updatePlayerPosition(x, y);
        }
    }

    updatePlayerPosition(x, y) {
        this.player.x = x;
        this.player.y = y;
    }

}